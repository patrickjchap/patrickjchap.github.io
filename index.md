### Static Analysis for Vulnerability Testing: OWASP LAPSE


Software security is a field that is growing rapidly and becoming more complicated every year. There are so many different attack vectors that it is impossible for a human to find out every single vulnerability by themselves. Software developers need tools to assist them in detecting and fixing security vulnerabilities. A common way to analyze code and detect problems is through the use of static analysis. Static analysis is the process of analyzing source code rather than analyzing the program while it is running. This is a white-box approach to analyzing a program because we have full access to the program’s internal structure. This means that the tool has access to the program’s flow tree and can analyze how the program works at the source code level. My original intention was to use a tool that was made by people at the well-respected group, OWASP. This program is called LAPSE and it can be used as an Eclipse plugin. However, it should be noted that this program seemed to stop development in 2011. Even though it had stopped having an active development process, I decided that I wanted to try testing the program anyway, especially since it was one of OWASP’s own programs.
To test this tool, I decided to use a Java EE web application that I have previously worked with. This application was developed at Boise State University as part of a Master’s Thesis. The program is titled GPMS (Grant Proposal Management System) and was designed to streamline the grant proposal process for Boise State. The application was built using XACML, an ABAC based technology for access control. With this type of application, it is important to try and close all the security holes. If any vulnerability was found on this application, it could lead to the entire workflow of the grant process being compromised. From my own personal experience, I have already done a lot of security testing with the application and have even fixed many of the vulnerabilities that were present on the old version of GPMS. Thankfully, I still possess the vulnerable version of GPMS and can use it to test LAPSE. 

Now, this is where things started to become a problem for me with testing LAPSE. LAPSE is a dated program (I mentioned 2011 earlier) and does not work very well with programs that use JAX-RS. I had previously thought that this wouldn’t be too much of an issue. However, LAPSE is very particular with the programs that it is trying to analyze. If there is anything that it does not expect, it will not work whatsoever. This is especially problematic because some of the technology that was used in GPMS was introduced well after 2011. In the end, LAPSE did not really seem to work with the program that I was trying to use. In any case, it would probably be a good idea to try a newer tool if you wanted to try some static analysis. However, I decided to come up with an alternative solution to where I could still use a static analysis tool to test for vulnerabilities. I decided to check out NIST’s website and look for static analysis tools. Luckily, I found a tool called AttackFlow. AttackFlow does static analysis of both C# and Java programs and has been updated in 2017. Thankfully, AttackFlow did work with GPMS

It should be noted that while LAPSE was free, AttackFlow is not. In order to obtain a license from AttackFlow you must get a quote from the company. However, I was lucky enough to be able to get a demo for the enterprise edition and I was able to test the software fully for around two weeks. To install AttackFlow, the user should have Visual Studio 2015 or newer installed on their machine. This is needed because the application focuses quite heavily on testing C# source code. However, in my case I wanted to focus on a Java web application. To do this, all I had to do was start a new scan and point the program to focus at the root directory of my Java source code. To run the program on C# code, you must point the program to the C# project’s .sln (solution) file. Once, the program is pointed in the right direction, the program reads through the source code and then tries to pinpoint where bugs and vulnerabilities may lie. For instance, the program will search for the “password” keyword and then see if there is any hard-coded data attached to the variable. If there is such an instance, then the program will report a possibility of a password being hard-coded in a program.

Now, in testing the application on GPMS, I was slightly disappointed. In all honesty, for my program, I was only able to pinpoint one useful vulnerability for the web application. For my expectations, I had thought that I would get more information on injection based attacks such as cross-site scripting. I did not really expect any sort of SQL injection considering GPMS is using MongoDB, but I knew for certain that the web application was vulnerable to cross-site scripting. Now, the one vulnerability that I did find was actually very useful.  The program found a HTTP header injection, which I had already known about and it does actually exist in the vulnerable version of the program. The vulnerability existed in the process of uploading/downloading attached files for a specific proposal document. This of course is a strong attack vector and this attack was very serious. I was actually initially surprised that this was the one vulnerability that the application did end up finding.

Now that I am finished with running the program, I have come to the realization that in many cases cross-site scripting isn’t easy to spot just with static code analysis. In fact, most of the time that I have found cross-site scripting to be an actual vulnerability on a website, it was actually testing the program’s interface. This is of course a more black-box and dynamic approach to testing, while AttackFlow is more white-box and a static tool. Thinking about this logically, it makes sense that it would be hard to tell if a program’s form inputs are subject to cross-site scripting, especially when there are several vectors that could actually lead to the injection being successful.

Overall, AttackFlow seems to do a fairly decent job at finding a lot of the more simple vulnerabilities that might occur in a web application. However, I did notice that it didn’t find some of the more obscure attacks that might be more prevalent in real world applications. With GPMS, many of the cross-site scripting attacks were not easily identifiable within the code, so it would make sense that it would be hard for a static analysis tool to find them. However, it is still important to note that AttackFlow was unable to find these attacks that were detrimental to the application.

